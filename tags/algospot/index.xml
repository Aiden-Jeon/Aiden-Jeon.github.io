<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algospot on Aiden's Camp</title><link>https://aiden-jeon.github.io/blog/tags/algospot/</link><description>Recent content in Algospot on Aiden's Camp</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 26 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://aiden-jeon.github.io/blog/tags/algospot/index.xml" rel="self" type="application/rss+xml"/><item><title>6. 무식하게 풀기</title><link>https://aiden-jeon.github.io/blog/p/6.-%EB%AC%B4%EC%8B%9D%ED%95%98%EA%B2%8C-%ED%92%80%EA%B8%B0/</link><pubDate>Tue, 26 Oct 2021 00:00:00 +0000</pubDate><guid>https://aiden-jeon.github.io/blog/p/6.-%EB%AC%B4%EC%8B%9D%ED%95%98%EA%B2%8C-%ED%92%80%EA%B8%B0/</guid><description>&lt;p>&lt;a class="link" href="https://book.algospot.com/" target="_blank" rel="noopener"
>알고리즘 문제 해결 전략&lt;/a>을 읽고 요약했습니다.&lt;/p>
&lt;hr>
&lt;h1 id="6-무식하게-풀기">&lt;a href="#6-%eb%ac%b4%ec%8b%9d%ed%95%98%ea%b2%8c-%ed%92%80%ea%b8%b0" class="header-anchor">&lt;/a>6. 무식하게 풀기
&lt;/h1>&lt;h2 id="61-도입">&lt;a href="#61-%eb%8f%84%ec%9e%85" class="header-anchor">&lt;/a>6.1 도입
&lt;/h2>&lt;h3 id="무식하게-풀기">&lt;a href="#%eb%ac%b4%ec%8b%9d%ed%95%98%ea%b2%8c-%ed%92%80%ea%b8%b0" class="header-anchor">&lt;/a>무식하게 풀기
&lt;/h3>&lt;ul>
&lt;li>Brute Force&lt;/li>
&lt;li>컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법&lt;/li>
&lt;/ul>
&lt;h3 id="완전-탐색">&lt;a href="#%ec%99%84%ec%a0%84-%ed%83%90%ec%83%89" class="header-anchor">&lt;/a>완전 탐색
&lt;/h3>&lt;ul>
&lt;li>Exhaustive search&lt;/li>
&lt;li>컴퓨터의 장점을 이용한 방법&lt;/li>
&lt;/ul>
&lt;h2 id="62-재귀호출과-완전탐색">&lt;a href="#62-%ec%9e%ac%ea%b7%80%ed%98%b8%ec%b6%9c%ea%b3%bc-%ec%99%84%ec%a0%84%ed%83%90%ec%83%89" class="header-anchor">&lt;/a>6.2 재귀호출과 완전탐색
&lt;/h2>&lt;h3 id="재귀-함수">&lt;a href="#%ec%9e%ac%ea%b7%80-%ed%95%a8%ec%88%98" class="header-anchor">&lt;/a>재귀 함수
&lt;/h3>&lt;ul>
&lt;li>Recursive Function&lt;/li>
&lt;li>자신이 수행한 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 자신을 호출해 실행하는 함수&lt;/li>
&lt;/ul>
&lt;p>eg) 1부터 n까지의 합을 구하는 함수&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 필수 조건: n&amp;gt;=1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 결과: 1부터 n까지의 합을 반환한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">n_sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 필수 조건: n&amp;gt;=1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 결과: 1부터 n까지의 합을 반환한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">recursive_sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">recursive_sum&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>n개의 숫자의 합을 구하는 작업을 n개의 조각으로 쪼개, 더할 각 숫자가 하나의 조각이 되도록 한다.&lt;/li>
&lt;li>재귀 호출을 이용하기 위해서는 이 조각 중 하나를 떼어내어 자신이 해결하고, 나머지 조각들을 자기 자신을 호출해서 해결한다.&lt;/li>
&lt;li>모든 재귀 함수는 &amp;lsquo;더 이상 쪼개지지 않는&amp;rsquo; 최소한의 작업에 도달 했을 때 답을 곧장 반환하는 조건문을 포함한다.
&lt;ul>
&lt;li>쪼개기지 않는 가장 작은 작업들 : 기저 사례 (base case)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="예제-중첩-반복문-대체하기">&lt;a href="#%ec%98%88%ec%a0%9c-%ec%a4%91%ec%b2%a9-%eb%b0%98%eb%b3%b5%eb%ac%b8-%eb%8c%80%ec%b2%b4%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>예제: 중첩 반복문 대체하기
&lt;/h3>&lt;p>eg) 0번 부터 차례대로 번호 매겨진 n개의 원소 중 네 개를 고르는 모든 경우를 출력하라&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>if) 5개? -&amp;gt; 5중 for 문&lt;/li>
&lt;li>if) 6개? -&amp;gt; 6중 for 문&lt;/li>
&lt;li>중첩 for문
&lt;ul>
&lt;li>골라야 할 원소의 수가 늘어날수록 코드가 길고 복잡해진다.&lt;/li>
&lt;li>골라야 할 원소의 수가 입력에 따라 달라질 수 있는 경우 사용할 수 없다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>-&amp;gt; 재귀 호출&lt;/p>
&lt;ul>
&lt;li>위 코드 조각이 하는 일을 네 개의 조각으로 나눌 수 있다.&lt;/li>
&lt;li>각 조각에서 하나를 고르고 남은 원소들을 고르는 작업을 자기 자신을 호출해 떠넘기는 재귀함수&lt;/li>
&lt;li>남은 원소를 고르는 &amp;lsquo;작업&amp;rsquo;을 다음과 같은 입력들의 집합으로 정의
&lt;ul>
&lt;li>원소들의 총 개수&lt;/li>
&lt;li>더 골라야 할 원소의 개수&lt;/li>
&lt;li>지금까지 고른 원소의 번호&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># n: 전체 원소의 수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># picked: 지금까지 고른 원소들의 번호&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># to_pick: 더 고를 원소의 수&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">pcik&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">picked&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">to_pick&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기저 사례: 더 고를 원소가 없을 때 고른 원소들을 출력한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">to_pick&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">print_picked&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pick&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 고를 수 있는 가장 작은 번호를 계산한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">smallest&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pick&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="n">pcik&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 이 단계에서는 원소 하나를 고른다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">next_n&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">smallest&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">picked&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next_n&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pick&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">picked&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">to_pick&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">picked&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://aiden-jeon.github.io/blog/imgs/algospot/chapter-06-1.jpeg"
loading="lazy"
alt="img"
>&lt;/p>
&lt;h3 id="예제-보글-게임">&lt;a href="#%ec%98%88%ec%a0%9c-%eb%b3%b4%ea%b8%80-%ea%b2%8c%ec%9e%84" class="header-anchor">&lt;/a>예제: 보글 게임
&lt;/h3>&lt;p>&lt;img src="https://aiden-jeon.github.io/blog/imgs/algospot/chapter-06-2.jpeg"
loading="lazy"
alt="img"
>
&lt;strong>Q)&lt;/strong>&lt;br>
보글(Boggle)은 그림 6.2(a)와 같은 5x5 크기의 알파벳 격자를 가지고 하는 게임&lt;br>
게임의 목적은 상하좌우/ 대각선으로 인접한 글자들을 이어서 단어를 찾아내는 것&lt;br>
eg) PRETTY, GIRL, REPEAT&lt;br>
각 글자들을 대각선으로도 이어질 수 있으며, 한 글자가 두 번 사용될 수도 있다.&lt;br>
-&amp;gt; &lt;code>has_word(y, x, word)&lt;/code>&lt;/p>
&lt;ul>
&lt;li>문제의 분할
&lt;ul>
&lt;li>각 글자를 하나의 조각으로 만드는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기자 사례의 선택
&lt;ul>
&lt;li>더 이상의 탐색 없이 간단히 답을 낼 수 있는 다음의 경우를 기저 사례로 선택
&lt;ol>
&lt;li>위치 (y, x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패&lt;/li>
&lt;li>(1번에 해당되지 않을 경우) 원하는 단어가 한 글자인 경우 성공&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구현
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">dx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">dy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">has_word&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">in_range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">board&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">word&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">direction&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dy&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">direction&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">new_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dx&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">direction&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">has_word&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">new_y&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">new_x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">word&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:]):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>시간 복잡도 분석
&lt;ul>
&lt;li>완전 탐색 알고리즘의 시간 복잡도 -&amp;gt; 가능한 모든 경우의 수를 전부 세보기&lt;/li>
&lt;li>if) 전부 A인 격자에서 AAAAAH 찾기
&lt;ul>
&lt;li>답이 없는 경우&lt;/li>
&lt;li>$8^{N-1}=O(8^N)$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="완전-탐색-레시피">&lt;a href="#%ec%99%84%ec%a0%84-%ed%83%90%ec%83%89-%eb%a0%88%ec%8b%9c%ed%94%bc" class="header-anchor">&lt;/a>완전 탐색 레시피
&lt;/h3>&lt;p>어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정&lt;/p>
&lt;ol>
&lt;li>단계
&lt;ul>
&lt;li>완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례&lt;/li>
&lt;li>최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을 지를 가늠&lt;/li>
&lt;li>만약 시간안에 계산할 수 없다면 설계 패러다임(추후 설명)을 적용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단계
&lt;ul>
&lt;li>가능한 모든 답의 후보를 만드는 과정을 여거래의 선택으로 나눈다.&lt;/li>
&lt;li>각 선택은 답의 호부를 만드는 과정의 한 조각&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단계
&lt;ul>
&lt;li>그 중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단계
&lt;ul>
&lt;li>조각이 하나 밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성 했으므로, 이것을 기저 사례로 선택해 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="이론적-배경-재귀-호출과-부분문제">&lt;a href="#%ec%9d%b4%eb%a1%a0%ec%a0%81-%eb%b0%b0%ea%b2%bd-%ec%9e%ac%ea%b7%80-%ed%98%b8%ec%b6%9c%ea%b3%bc-%eb%b6%80%eb%b6%84%eb%ac%b8%ec%a0%9c" class="header-anchor">&lt;/a>이론적 배경: 재귀 호출과 부분문제
&lt;/h3>&lt;h4 id="문제와-부문문제">&lt;a href="#%eb%ac%b8%ec%a0%9c%ec%99%80-%eb%b6%80%eb%ac%b8%eb%ac%b8%ec%a0%9c" class="header-anchor">&lt;/a>문제와 부문문제
&lt;/h4>&lt;p>예시)&lt;/p>
&lt;ul>
&lt;li>문제: 주어진 자연수를 정렬하라&lt;/li>
&lt;li>문제: ${16, 7, 9, 1, 31}$을 정렬하라&lt;/li>
&lt;/ul>
&lt;p>차이점: 전자는 입력을 지정하지 않고 후자는 특별한 입력 지정&lt;/p>
&lt;p>보글 게임 예시)&lt;/p>
&lt;ol>
&lt;li>현재 위치 (y, x)에 단어의 첫글자가 있는가?&lt;/li>
&lt;li>윗 칸에서 시작해서, 단어의 나머지 글자를 찾을 수 있는가?&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>2번 이후
&lt;ul>
&lt;li>원래 문제에서 한 조각을 떼어 냈을 뿐, 형식이 같은 또 다른 문제를 푼 결과&lt;/li>
&lt;li>문제를 구성하는 조각들 중 한 조각을 뺏기 때문에, 이 문제들은 원래 문제의 일부&lt;/li>
&lt;li>-&amp;gt; 이런 문제들을 원래의 부분문제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="67-최적화-문제">&lt;a href="#67-%ec%b5%9c%ec%a0%81%ed%99%94-%eb%ac%b8%ec%a0%9c" class="header-anchor">&lt;/a>6.7 최적화 문제
&lt;/h2>&lt;ul>
&lt;li>문제의 답이 하나가 아니라 여러 개이고, 그 중에서 어떤 기준에 따라 가장 좋은 답을 찾아내는 문제&lt;/li>
&lt;li>eg) $n$개의 원소 중 $r$개를 순서없이 골라내는 문제
&lt;ul>
&lt;li>최적화 문제 x&lt;/li>
&lt;li>우리가 원하는 답은 딱 하나 밖에 없다 -&amp;gt; 더 좋은 답이나 덜 좋은 답이 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>eg) $n$개 사과 중 $r$개 골라서 무게의 합을 최대화하는 문제
&lt;ul>
&lt;li>최적화 문제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최적화 문제 해결 방법
&lt;ul>
&lt;li>완전 탐색&lt;/li>
&lt;li>동적 계호기법&lt;/li>
&lt;li>조합 탐색&lt;/li>
&lt;li>최적화 문제 -&amp;gt; 결정 문제로 변환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="예제-여행하는-예판원-문제-traveling-salssman-problem-tsp">&lt;a href="#%ec%98%88%ec%a0%9c-%ec%97%ac%ed%96%89%ed%95%98%eb%8a%94-%ec%98%88%ed%8c%90%ec%9b%90-%eb%ac%b8%ec%a0%9c-traveling-salssman-problem-tsp" class="header-anchor">&lt;/a>예제: 여행하는 예판원 문제 (Traveling Salssman Problem, TSP)
&lt;/h3>&lt;p>어떤 나라에 $n(2 \le n \le 10)$개의 큰 도시가 있다.
한 영업사원이 한 도시에서 출발해 다른 도시들을 전부 한 번씩 방문한 뒤 시작 도시로 돌아오려고 한다.
각 도시들은 모두 직선도로로 연결되어 있다.
영업사원이 여행해야 할 거리 중 가장 짧은 경로는 ?&lt;/p>
&lt;h4 id="무식하게-풀-수-있을까">&lt;a href="#%eb%ac%b4%ec%8b%9d%ed%95%98%ea%b2%8c-%ed%92%80-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>무식하게 풀 수 있을까?
&lt;/h4>&lt;p>시간안에 답을 구할 수 있을까?&lt;br>
-&amp;gt; $(n-1)!$ -&amp;gt; $9!$ -&amp;gt; $362,880$ -&amp;gt; 1초안에 처리할 수 있는 숫자&lt;/p>
&lt;h4 id="재귀-호출을-통한-답안-생성">&lt;a href="#%ec%9e%ac%ea%b7%80-%ed%98%b8%ec%b6%9c%ec%9d%84-%ed%86%b5%ed%95%9c-%eb%8b%b5%ec%95%88-%ec%83%9d%ec%84%b1" class="header-anchor">&lt;/a>재귀 호출을 통한 답안 생성
&lt;/h4>&lt;ul>
&lt;li>$n$개의 도시로 구성된 경로를 $n$개의 조각으로 나눠 앞에서부터 도시를 하나씩 추가해 경로를 만들기&lt;/li>
&lt;li>&lt;code>shortest_path(path)=path&lt;/code> -&amp;gt; 지금까지 만든 경로, 나머지 도시를 모두 방문하는 경로들 중 가장 짧은 것을 반환한다.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">shortest_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_length&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 기저 사례: 모든 도시를 다 방문했을 때는 시작도시로 돌아가고 종료&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">current_length&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dist&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]][&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">987654321&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">next_visit&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">next_visit&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">here&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">next_visit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">next_visit&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cand&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">shorted_path&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">visited&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">current_length&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dist&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">here&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">next_visit&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cand&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">next_visit&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>5. 알고리즘의 정당성 증명</title><link>https://aiden-jeon.github.io/blog/p/5.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%A0%95%EB%8B%B9%EC%84%B1-%EC%A6%9D%EB%AA%85/</link><pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate><guid>https://aiden-jeon.github.io/blog/p/5.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%A0%95%EB%8B%B9%EC%84%B1-%EC%A6%9D%EB%AA%85/</guid><description>&lt;p>&lt;a class="link" href="https://book.algospot.com/" target="_blank" rel="noopener"
>알고리즘 문제 해결 전략&lt;/a>을 읽고 요약했습니다.&lt;/p>
&lt;hr>
&lt;h1 id="5-알고리즘의-정당성-증명">&lt;a href="#5-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%a0%95%eb%8b%b9%ec%84%b1-%ec%a6%9d%eb%aa%85" class="header-anchor">&lt;/a>5. 알고리즘의 정당성 증명
&lt;/h1>&lt;h2 id="51-도입">&lt;a href="#51-%eb%8f%84%ec%9e%85" class="header-anchor">&lt;/a>5.1 도입
&lt;/h2>&lt;p>알고리즘의 정당성 증명&lt;/p>
&lt;ul>
&lt;li>단위 테스트
&lt;ul>
&lt;li>알고리즘에 문제가 있음을 증명할 수는 있어도 문제가 없음을 증명할 수는 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 방법이 필요&lt;/li>
&lt;/ul>
&lt;h2 id="52-수학적-귀납법과-반복문-불변식">&lt;a href="#52-%ec%88%98%ed%95%99%ec%a0%81-%ea%b7%80%eb%82%a9%eb%b2%95%ea%b3%bc-%eb%b0%98%eb%b3%b5%eb%ac%b8-%eb%b6%88%eb%b3%80%ec%8b%9d" class="header-anchor">&lt;/a>5.2 수학적 귀납법과 반복문 불변식
&lt;/h2>&lt;p>eg) 100개의 도미노가 있고 다음 두가지 사실을 안다고 가정&lt;/p>
&lt;ul>
&lt;li>첫 번째 도미노는 직접 손으로 밀어서 쓰러트인다.&lt;/li>
&lt;li>한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.&lt;/li>
&lt;/ul>
&lt;p>-&amp;gt; 마지막 도미노 또한 당연히 쓰러진다.&lt;br>
-&amp;gt; 직관적으로 알 수 있음&lt;/p>
&lt;h3 id="수학적-귀납법">&lt;a href="#%ec%88%98%ed%95%99%ec%a0%81-%ea%b7%80%eb%82%a9%eb%b2%95" class="header-anchor">&lt;/a>수학적 귀납법
&lt;/h3>&lt;ul>
&lt;li>Mathmetical Induction&lt;/li>
&lt;li>반복적인 구조를 갖는 명제들을 증명하는데 유용하게 사용되는 증명 기법&lt;/li>
&lt;/ul>
&lt;h4 id="귀납법-단계">&lt;a href="#%ea%b7%80%eb%82%a9%eb%b2%95-%eb%8b%a8%ea%b3%84" class="header-anchor">&lt;/a>귀납법 단계
&lt;/h4>&lt;ol>
&lt;li>단계 나누기
&lt;ul>
&lt;li>증명하고 싶은 사실을 여러 단계로 나눈다.&lt;/li>
&lt;li>100개의 도미노를 하나씩 나눔&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첫 단계 증명
&lt;ul>
&lt;li>첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.&lt;/li>
&lt;li>첫 번째 도미노가 넘어짐을 증명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>귀납 증명
&lt;ul>
&lt;li>다음 단계에서도 성립함을 보인다.&lt;/li>
&lt;li>한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="사다리-게임">&lt;a href="#%ec%82%ac%eb%8b%a4%eb%a6%ac-%ea%b2%8c%ec%9e%84" class="header-anchor">&lt;/a>사다리 게임
&lt;/h4>&lt;p>맨 위와 맨 아래가 1:1 대응이다.
&lt;img src="https://aiden-jeon.github.io/blog/imgs/algospot/chapter-05-1.jpeg"
loading="lazy"
alt="imgs"
>&lt;/p>
&lt;ol>
&lt;li>단계 나누기
&lt;ul>
&lt;li>텅 빈 $N$개의 세로줄에서부터 시작해서 원하는 사다리가 될 때까지 하나씩 가로줄을 그어 간다. 이때, 가로즐을 하나 긋는 것을 한 단계라고 정의&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>첫 단계 증명
&lt;ul>
&lt;li>텅 빈 $N$개의 세로줄에서는 맨 위 선택지와 맨 아래 선택지가 1:1 대응&lt;/li>
&lt;li>첫 번째 도미노가 넘어짐을 증명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>귀납 증명
&lt;ul>
&lt;li>가로 줄을 그어서 두 개의 세로줄을 연결, 이 때 두 세로줄의 결과는 서로 뒤바뀐다.&lt;/li>
&lt;li>두 세로줄의 결과가 바뀌어도 1:1 대응은 변하지 않는다&lt;/li>
&lt;li>-&amp;gt; 다음 단계에서도 1:1 대응 특성 유지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>-&amp;gt; 따라서 귀납법에 의해 가로줄만을 사용하는 사다리들은 항상 1:1 대응된다.&lt;/p>
&lt;h3 id="반복문-불변식">&lt;a href="#%eb%b0%98%eb%b3%b5%eb%ac%b8-%eb%b6%88%eb%b3%80%ec%8b%9d" class="header-anchor">&lt;/a>반복문 불변식
&lt;/h3>&lt;p>귀납법은 알고리즘의 정당성을 증명할 때 가장 유용하게 사용되는 기법이다.&lt;/p>
&lt;ul>
&lt;li>대부분의 알고리즘은 어떠한 형태로든 반복적인 요소를 가지고 있기 때문이다.&lt;/li>
&lt;li>귀납법은 이런 알고리즘들이 옳은 답을 계산함을 보이기 위해서
&lt;ul>
&lt;li>알고리즘의 각 단계가 정답으로 가는 길 위에 있음을 보이고&lt;/li>
&lt;li>결과적으로는 알고리즘의 답이 옳음을 보인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="반복분-불변식">&lt;a href="#%eb%b0%98%eb%b3%b5%eb%b6%84-%eb%b6%88%eb%b3%80%ec%8b%9d" class="header-anchor">&lt;/a>반복분 불변식
&lt;/h4>&lt;ul>
&lt;li>반복문의 내용이 한 번 실행될 때 마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 잘 있는지를 명시하는 조건&lt;/li>
&lt;li>반복문이 마지막에 정답을 계산하기 위해서는 항상 이 식이 변하지 않고 성립해야 한다.&lt;/li>
&lt;/ul>
&lt;h4 id="불변식을-이용한-반복문의-정당성-증명">&lt;a href="#%eb%b6%88%eb%b3%80%ec%8b%9d%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%9c-%eb%b0%98%eb%b3%b5%eb%ac%b8%ec%9d%98-%ec%a0%95%eb%8b%b9%ec%84%b1-%ec%a6%9d%eb%aa%85" class="header-anchor">&lt;/a>불변식을 이용한 반복문의 정당성 증명
&lt;/h4>&lt;ol>
&lt;li>반복문 진입시에 분변식이 성립함을 보인다.&lt;/li>
&lt;li>반복문 내용이 불변식을 깨뜨리지 않음을 보인다.
&lt;ul>
&lt;li>반복문 내용이 시작할 때 분변식이 성립했다면 내용이 끝날때도 불변식이 항상 성립함을 보인다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반복문 종료시에 불변식이 성립하면 항상 우리가 정답을 구했음을 보인다.&lt;/li>
&lt;/ol>
&lt;p>eg) &lt;code>while&lt;/code>문&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 불변식은 여기에서 성립해야 한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">어떤&lt;/span> &lt;span class="n">조건&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 반복문 내용의 시작&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 반복문 내용의 끝&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 불변식은 여기에서도 성립해야 한다.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="이진-탐색과-반복분-불변식">&lt;a href="#%ec%9d%b4%ec%a7%84-%ed%83%90%ec%83%89%ea%b3%bc-%eb%b0%98%eb%b3%b5%eb%b6%84-%eb%b6%88%eb%b3%80%ec%8b%9d" class="header-anchor">&lt;/a>이진 탐색과 반복분 불변식
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 필수 조건: A는 오름차순으로 정렬되어 있다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 결과: A[i-1] &amp;lt; x &amp;lt;= A[i]인 i를 반환한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 이 때 A[-1]=음의 무한대, A[N]=양의 무한대라고 가정한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">binsearch&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hi&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 반복문 불변식 1: lo &amp;lt; hi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 반복문 불변식 2: A[lo] &amp;lt; x &amp;lt;= A[hi]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">lo&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">hi&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mid&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">lo&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">hi&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">mid&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">lo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hi&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mid&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">hi&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>$lo+1=hi$
&lt;ul>
&lt;li>while 문이 종료된다.
&lt;ul>
&lt;li>$lo+1 \ge hi$&lt;/li>
&lt;li>불변식에 의하면 $lo &amp;lt; hi$이니, $lo+1 = hi$&lt;/li>
&lt;li>$A[lo] &amp;lt; x \le A[hi]$: 불변식 성립&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>초기 조건
&lt;ul>
&lt;li>while 문이 시작할 때 &lt;code>lo&lt;/code>, &lt;code>hi&lt;/code>는 초기값 &lt;code>-1&lt;/code>, &lt;code>n&lt;/code>으로 초기화된 상태&lt;/li>
&lt;li>만약 &lt;code>n=0&lt;/code>이라면 while문을 건너 뛰게 됨 -&amp;gt; 불변식 1 성립&lt;/li>
&lt;li>$A[-1] = -\infty, A[N]=\infty$라고 가정 -&amp;gt; 불변식 2 성립&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>유지 조건
&lt;ul>
&lt;li>while 문 내부가 불변식을 깨뜨리지 않음&lt;/li>
&lt;li>불변식 1
&lt;ul>
&lt;li>while문 내부로 들어옴&lt;/li>
&lt;li>-&amp;gt; &lt;code>hi&lt;/code>와 &lt;code>lo&lt;/code>의 차이가 2 이상&lt;/li>
&lt;li>-&amp;gt; &lt;code>mid&lt;/code>는 항상 두 값 사이에 위치&lt;/li>
&lt;li>-&amp;gt; &lt;code>mid&lt;/code>를 &lt;code>lo,hi&lt;/code> 어디에 대입해도 항상 불변식 1은 성립&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>불변식 2
&lt;ul>
&lt;li>$A[mid] &amp;lt; x$인 경우
&lt;ul>
&lt;li>반복문을 시작할 때 $x \le A[hi]$임을 알고 있음&lt;/li>
&lt;li>-&amp;gt; $A[mid] &amp;lt; x \le A[hi]$이므로, &lt;code>lo&lt;/code>에 &lt;code>mid&lt;/code>를 대입해도 불변식 2는 성립&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$x \le A[mid]$인 경우
&lt;ul>
&lt;li>$A[lo] &amp;lt; x$와 합치면&lt;/li>
&lt;li>-&amp;gt; $A[lo] &amp;lt; x \le A[mid]$&lt;/li>
&lt;li>-&amp;gt; &lt;code>hi&lt;/code>에 &lt;code>mid&lt;/code>를 대입해도 불변식 2는 성립&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="삽입-정렬과-반복문-불변식">&lt;a href="#%ec%82%bd%ec%9e%85-%ec%a0%95%eb%a0%ac%ea%b3%bc-%eb%b0%98%eb%b3%b5%eb%ac%b8-%eb%b6%88%eb%b3%80%ec%8b%9d" class="header-anchor">&lt;/a>삽입 정렬과 반복문 불변식
&lt;/h3>&lt;h4 id="구현-코드">&lt;a href="#%ea%b5%ac%ed%98%84-%ec%bd%94%eb%93%9c" class="header-anchor">&lt;/a>구현 코드
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">insertion_sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 불변식 a: A[0, ..., i-1]은 이미 정렬되어 있다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># A[0, ..., i-1]에 A[i]를 끼워 넣는다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 불변식 b: A[j+1, ..., i]의 모든 원소는 A[j]보다 크다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 불변식 c: A[0, ..., i]구간은 A[j]를 제외하면 정렬되어 있다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">j&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>초기 조건: 반복문이 시작할 때 i=0이면 해당 구간은 비어 있으니 항상 정렬되어 있다고 가정한다.&lt;/li>
&lt;li>불변식 유지: for문의 내용이 종료할 때 이 불변식이 깨지지 않고 유지됨을 보이기 위해서는 while문의 정당성을 증명&lt;/li>
&lt;/ul>
&lt;p>eg) 이해를 위한 example&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;code>i = 0&lt;/code>&lt;/p>
&lt;ul>
&lt;li>불변식 a
&lt;ul>
&lt;li>&lt;code>A[0, ... -1]&lt;/code>은 정렬되어 있다.&lt;/li>
&lt;li>&lt;code>A[0, ... -1]&lt;/code>에 &lt;code>A[0]&lt;/code>를 끼어 넣는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>j = 0&lt;/code>
&lt;ul>
&lt;li>while문 스킵&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>i = 1&lt;/code>&lt;/p>
&lt;ul>
&lt;li>불변식 a
&lt;ul>
&lt;li>&lt;code>A[0, ... 0]&lt;/code>은 정렬되어 있다.&lt;/li>
&lt;li>&lt;code>A[0, ... 0]&lt;/code>에 &lt;code>A[1]&lt;/code>를 끼어 넣는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>j = 1&lt;/code>
&lt;ul>
&lt;li>&lt;code>j &amp;gt; 0 and A[0] &amp;gt; A[1]&lt;/code>&lt;/li>
&lt;li>&lt;code>A[0, 1]&lt;/code> &amp;lt;- sorted&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>i = 2&lt;/code>&lt;/p>
&lt;ul>
&lt;li>불변식 a
&lt;ul>
&lt;li>&lt;code>A[0, ... 1]&lt;/code>은 정렬되어 있다.&lt;/li>
&lt;li>&lt;code>A[0, ... 1]&lt;/code>에 &lt;code>A[2]&lt;/code>를 끼어 넣는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="초기-조건">&lt;a href="#%ec%b4%88%ea%b8%b0-%ec%a1%b0%ea%b1%b4" class="header-anchor">&lt;/a>초기 조건
&lt;/h4>&lt;ol>
&lt;li>$j=0$
&lt;ul>
&lt;li>$j=0$ 이라면 불변식 (b)에 의해 $A[j]$가 $A[0, &amp;hellip;, i]$ 구간 중 가장 작은 수가 된다.&lt;/li>
&lt;li>불변식 (c)와 합쳐 보면 $A[0, &amp;hellip;, i]$ 구간 전체가 정렬되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$j&amp;gt;0$
&lt;ul>
&lt;li>$j&amp;gt;0$이고 $A[j-1] \le A[j]$라면, 불변식 (b)와 합쳐 $A[j-1] \le A[j] &amp;lt; A[j+1]$ 가 된다.&lt;/li>
&lt;li>불변식 (c)와 합쳐 보면 $A[0, &amp;hellip;, i]$ 구간 전체가 정렬되어 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="불변식-유지">&lt;a href="#%eb%b6%88%eb%b3%80%ec%8b%9d-%ec%9c%a0%ec%a7%80" class="header-anchor">&lt;/a>불변식 유지
&lt;/h4>&lt;p>(b)와 (c)가 항상 성립함을 증명&lt;/p>
&lt;ul>
&lt;li>(b) 초기 조건: while 문 진입시에 $A[j+1, &amp;hellip;, i]$ 구간은 (빈 구간)(j+1==i)이므로 (b)는 참&lt;/li>
&lt;li>(b) 유지 조건: while 문 내용이 실행되었다는 말은 $A[j-1]&amp;gt;A[j]$ 라는 의미. 이 둘을 교체하고 $j$를 1 줄이면 (b)는 여전히 참&lt;/li>
&lt;li>(c) 초기 조건: 불변식 (a)에 의해 구간 $A[0, &amp;hellip;, i-1]]$은 항상 정렬되어 있으니 while문 진입 초기시에는 (c)는 항상 참&lt;/li>
&lt;li>(c) 유지 조건: 그림 (c)에 $A[j]$ 와 이전 원소를 교체한다고 해도 회색 원소들 간의 상대적 순서는 변하지 않기에 (c)는 항상 참&lt;br>
&lt;img src="https://aiden-jeon.github.io/blog/imgs/algospot/chapter-05-2.jpeg"
loading="lazy"
alt="imgs"
>&lt;/li>
&lt;/ul>
&lt;h3 id="단정문을-이용해-반복문-불변식-강제하기">&lt;a href="#%eb%8b%a8%ec%a0%95%eb%ac%b8%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%b4-%eb%b0%98%eb%b3%b5%eb%ac%b8-%eb%b6%88%eb%b3%80%ec%8b%9d-%ea%b0%95%ec%a0%9c%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>단정문을 이용해 반복문 불변식 강제하기
&lt;/h3>&lt;p>불변식을 주석으로만 달아두는 것이 아니라 단정문으로 강제
-&amp;gt; 불변식이 깨지면 프로그램이 종료되게해서 불변식이 깨졌음을 쉽게 알 수 있음&lt;/p>
&lt;h2 id="53-귀류법">&lt;a href="#53-%ea%b7%80%eb%a5%98%eb%b2%95" class="header-anchor">&lt;/a>5.3 귀류법
&lt;/h2>&lt;ul>
&lt;li>우리가 원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못 됏음을 찾아내는 증명 기법&lt;/li>
&lt;li>어떤 선택이 항상 최선임을 증명하고자 할 때 많이 이용됨
&lt;ul>
&lt;li>-&amp;gt; 우리가 선택한 답보다 좋은 답이 있다고 가정한 후에, 사실 그럴일이 있을 수 없음을 보이면 우리가 최선의 답을 선택했음을 보임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="책상-쌓기">&lt;a href="#%ec%b1%85%ec%83%81-%ec%8c%93%ea%b8%b0" class="header-anchor">&lt;/a>책상 쌓기
&lt;/h3>&lt;p>$Q)$ 상장 형태로 된 책장을 여러 개 쌓아 올릴려고 한다.&lt;br>
각 책장마다 버틸수 있는 최대 무게 $M_i$와 자신의 무게 $W_i$가 주어진다.&lt;br>
이 때 책장을 가장 높이 쌓는다면 몇 개나 쌓을 수 있을까?&lt;br>
단, $above(i)$가 $i$번 책상 위에 쌓인 모든 책장의 집합이라고 할 때, 다음이 성립해야 한다.
$$\sum_{j\in above(i)}{w_j \le M_i}$$&lt;/p>
&lt;p>-&amp;gt; 책상위에 올라간 다른 책장들의 무게의 합이 견딜 수 있는 최대 무게를 초과하면 안 된다.&lt;/p>
&lt;p>$A)$ what if? 항상 무거운 책장을 아래 쪽에 쌓는 것이 좋다는 사실을 알고 있다.&lt;br>
-&amp;gt; 주어진 책상들을 정렬 후 순서에 신경 쓰지 않고 어느 책장을 고를지만 집중&lt;br>
-&amp;gt; $M_i$로 정렬? $W_i$로 정렬?&lt;br>
-&amp;gt; 정답은 $M_i + W_i$가 큰 것부터 아래에&lt;/p>
&lt;p>$Proof)$&lt;br>
$M_i + W_i$가 더 큰 책장 A가 더 작은 책장 B에 올라간 형태&lt;br>
-&amp;gt; A와 B의 위치를 항상 바꿀 수 있음을 증명&lt;/p>
&lt;p>$$M_A &amp;gt; M_B + W_B - W_A$$
A 위에 올라가 있는 상자들의 무게의 합 = $X$
$$M_B &amp;gt; M_A + X$$
=&amp;gt;
$$M_A &amp;gt; M_B + W_B - W_A \ge + X + W_B$$&lt;/p>
&lt;p>A도 B와 나머지 모든 상자를 지탱할 수 있음.&lt;br>
따라서, 우리가 원하는 순서대로 쌓을 때 가장 높은 탑을 알지 못할 경우의 수는 존재하지 않는다.&lt;/p>
&lt;h2 id="54-다른-기술들">&lt;a href="#54-%eb%8b%a4%eb%a5%b8-%ea%b8%b0%ec%88%a0%eb%93%a4" class="header-anchor">&lt;/a>5.4 다른 기술들
&lt;/h2>&lt;h3 id="비둘기-집의-원리">&lt;a href="#%eb%b9%84%eb%91%98%ea%b8%b0-%ec%a7%91%ec%9d%98-%ec%9b%90%eb%a6%ac" class="header-anchor">&lt;/a>비둘기 집의 원리
&lt;/h3>&lt;ul>
&lt;li>Pigeonhole Principla&lt;/li>
&lt;li>10 마리의 비둘기가 9개의 비둘기 집에 들어 깟다면, 2 마리 이상이 들어간 비둘기 집은 반드시 하나 있기 마련이다.&lt;/li>
&lt;/ul>
&lt;h3 id="동전-뒤집기">&lt;a href="#%eb%8f%99%ec%a0%84-%eb%92%a4%ec%a7%91%ea%b8%b0" class="header-anchor">&lt;/a>동전 뒤집기
&lt;/h3>&lt;p>100개의 동전이 바닥에 깔려 있는데 이 중 $F$개는 앞면, $100-F$개는 뒷면이다.&lt;br>
이 동전들이 모두 앞면으로 오게 하고 싶은데, 한 번 뒤집을 때 반드시 $X$개를 뒤집어야 한다.&lt;br>
이 때 뒤집는 횟수를 최소화 하고 싶을 때 답의 상한은?&lt;br>
=&amp;gt; 100&lt;/p>
&lt;h3 id="순환-소수-찾기">&lt;a href="#%ec%88%9c%ed%99%98-%ec%86%8c%ec%88%98-%ec%b0%be%ea%b8%b0" class="header-anchor">&lt;/a>순환 소수 찾기
&lt;/h3>&lt;p>분수 $\frac{a}{b}$가 주어졌을 때 실수 연산을 사용하지 않고 이 분수를 소수 형태로 출력하려고 한다.&lt;br>
eg) $\frac{3}{8}=0.375$, $\frac{4912}{400}=11.78$&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 분수 a/b의 소수 표현을 출력한다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># a&amp;gt;=0, b&amp;gt;0 이라고 가정함&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">print_demical&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 첫 번째와 두 번째 사이에 소수점을 찍는다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="s2">&amp;#34;.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>if) $\frac{1}{11}$이 입력 -&amp;gt; $0.090909&amp;hellip;$ 무한 소수&lt;/p>
&lt;ul>
&lt;li>&lt;code>a%b&lt;/code>의 결과는 언제나 &lt;code>[0, b-1]&lt;/code> 범위의 값을 가정한다.&lt;/li>
&lt;li>while문이 b+1번 반복될 때까지 함수가 종료되지 않음
&lt;ul>
&lt;li>-&amp;gt; a%b의 결과는 b가지의 결과를 가질 수 있음&lt;/li>
&lt;li>-&amp;gt; 결과가 중복되는 경우가 반드시 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구성적-증명">&lt;a href="#%ea%b5%ac%ec%84%b1%ec%a0%81-%ec%a6%9d%eb%aa%85" class="header-anchor">&lt;/a>구성적 증명
&lt;/h3>&lt;ul>
&lt;li>Constructive Prrof&lt;/li>
&lt;li>우리가 원하는 어떤 답이 존재한다는 사실을 증명하기 위해 사용&lt;/li>
&lt;li>답이 존재한다는 사실을 노증하는 것(귀납법, 귀류법) &amp;lt;=&amp;gt; 답의 실제 예를 들거나 만드는 방법을 제시하는 증명(구성적 증명)&lt;/li>
&lt;/ul>
&lt;h4 id="안정적-결혼-문제">&lt;a href="#%ec%95%88%ec%a0%95%ec%a0%81-%ea%b2%b0%ed%98%bc-%eb%ac%b8%ec%a0%9c" class="header-anchor">&lt;/a>안정적 결혼 문제
&lt;/h4>&lt;p>&lt;strong>문제 풀이 알고리즘&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>처음에는 여성들이 모두 자신이 가장 선호하는 남성의 앞에 가서 프러포즈를 한다. 남성이 그 중 제일 마음에 드는 여성을 고르면 나머지는 제자리로 돌아간다.&lt;/li>
&lt;li>제자리도 돌아간 여성들이 (상대에게 짝이 있던 없던 관계없이) 다음으로 마음에 드는 남성에게 프러포즈한다. 남성은 현재 자기 짝보다 마음에 드는 여성이 다가오면, 현재 짝을 돌려 보낸다.&lt;/li>
&lt;li>더 프러포즈를 할 여성이 없을 때까지 2를 반복한다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>증명&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>종료 증명
&lt;ul>
&lt;li>각 여성은 돌아갈 때 마다 지금까지 프러포즈했던 남성들보다 우선 순위가 낮은 남성에게 프러포즈한다.&lt;/li>
&lt;li>따라서 각 여성이 최대 $n$명의 남성들에게 순서대로 프러포즈한 이후에는 더 이상 프러포즈를 할 남성이 없으므로, 이 과정을 언젠간 반드시 종료한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 사람이 짝을 찾는지 증명
&lt;ul>
&lt;li>프러포즈를 받은 남성은 그 중 한 사람을 반드시 선택하고, 더 우선순위가 높은 여성이 프러포즈해야만 짝을 바꾸므로 한 번이라도 프러포즈를 받은 남성은 항상 짝이 있다.&lt;/li>
&lt;li>귀류법을 적용
&lt;ul>
&lt;li>남녀 한 사람씩 짝을 못 찾음&lt;/li>
&lt;li>여성은 우선순위가 높은 순서대로 모두에게 프러포즈하기 때문에 이 남성에게 프러포즈&lt;/li>
&lt;li>남성은 프러포즈를 받아 들여야 함&lt;/li>
&lt;li>짝을 찾지 못하는 사람은 있을 수 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>짝들의 안정성
&lt;ul>
&lt;li>귀류법
&lt;ul>
&lt;li>짝이 아닌 두 남녀가 서로 자신의 짝보다 상대방을 더 선호한다고 가정&lt;/li>
&lt;li>여성은 지금 자신의 짝 이전에 그 남성에게 반드시 프러포즈 했어야 함&lt;/li>
&lt;li>그런데도 이 남성이 이 여성과 짝 지어지지 않았따는 것은 더 마음에 드는 여성에게 프러포즈 받아서 수락함&lt;/li>
&lt;li>프러포즈 받았떤 여성보다 맘에 들지 않은 여성과 최종적으로 짝이 되는일은 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>4. 알고리즘의 시간 복잡도 분석</title><link>https://aiden-jeon.github.io/blog/p/4.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D/</link><pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate><guid>https://aiden-jeon.github.io/blog/p/4.-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D/</guid><description>&lt;p>&lt;a class="link" href="https://book.algospot.com/" target="_blank" rel="noopener"
>알고리즘 문제 해결 전략&lt;/a>을 읽고 요약했습니다.&lt;/p>
&lt;hr>
&lt;h1 id="4-알고리즘의-시간-복잡도-분석">&lt;a href="#4-%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84-%eb%b6%84%ec%84%9d" class="header-anchor">&lt;/a>4. 알고리즘의 시간 복잡도 분석
&lt;/h1>&lt;h2 id="41-도입">&lt;a href="#41-%eb%8f%84%ec%9e%85" class="header-anchor">&lt;/a>4.1 도입
&lt;/h2>&lt;h3 id="알고리즘의-속도는-어떻게-측정할-수-있을까">&lt;a href="#%ec%95%8c%ea%b3%a0%eb%a6%ac%ec%a6%98%ec%9d%98-%ec%86%8d%eb%8f%84%eb%8a%94-%ec%96%b4%eb%96%bb%ea%b2%8c-%ec%b8%a1%ec%a0%95%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>알고리즘의 속도는 어떻게 측정할 수 있을까?
&lt;/h3>&lt;p>프로그램을 구현한 뒤 같은 입력에 대해 프로그래밍의 수행시간을 비교&lt;/p>
&lt;p>-&amp;gt; &lt;strong>부적합&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>사용 프로그래밍 언엉, 하드웨어, 운영체제, 컴파일러등 수 많은 요소에 의해 변할 수 있음&lt;/li>
&lt;li>프로그램의 실제 수행 시간이 다양한 입력에 대한 실험 시간을 반영하지 못함
&lt;ul>
&lt;li>입력의 크기나 특성에 따라 수행 시간이 달라질 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="반복문이-지배한다">&lt;a href="#%eb%b0%98%eb%b3%b5%eb%ac%b8%ec%9d%b4-%ec%a7%80%eb%b0%b0%ed%95%9c%eb%8b%a4" class="header-anchor">&lt;/a>반복문이 지배한다
&lt;/h3>&lt;ul>
&lt;li>지배한다 (Dominate)
&lt;ul>
&lt;li>한가지 항목이 전체의 대소를 좌지우지 하는 것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>알고리즘의 시간을 지배하는 것 -&amp;gt; &lt;strong>&amp;ldquo;반복문&amp;rdquo;&lt;/strong>
&lt;ul>
&lt;li>입력의 크기가 작을 때는 반복 외의 다른 부분들이 갖는 비중이 클 수 있지만, 입력의 크기가 커지면 커질수록 반복문이 알고리즘의 수행시간을 지배한다.&lt;/li>
&lt;li>반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>eg) 주어진 배열에서 가장 많이 등장하는 숫자를 반환하기
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">majority_1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">majority&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">majority_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">count&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">majority_count&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">majority_count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">count&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">majority&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">majority&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>알고리즘의 수행시간은 입력 크기 N에 따라 변한다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>N 번 수행되는 반복문이 두 개 겹쳐 있으므로, 반복문의 가장 안쪽은 항상 $N^2$번 실행&lt;/p>
&lt;p>-&amp;gt; 알고리즘의 수행시간은 $N^2$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>if 입력으로 주어지는 숫자들이 100점 만점의 수학 점수
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">majority_2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">101&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">count&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">majority&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">101&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">majority&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">majority&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">majority&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>하나는 N번, 하나는 100번&lt;/p>
&lt;p>-&amp;gt; 전체 반복문 수행 횟수 N + 100&lt;/p>
&lt;/li>
&lt;li>
&lt;p>N이 커질수록 후자의 방복문의 비중은 감소한다.&lt;/p>
&lt;p>-&amp;gt; 알고리즘 수행시간: $N$&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="42-선형-시간-알고리듬">&lt;a href="#42-%ec%84%a0%ed%98%95-%ec%8b%9c%ea%b0%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%eb%93%ac" class="header-anchor">&lt;/a>4.2 선형 시간 알고리듬
&lt;/h2>&lt;h3 id="다이어트-현황-파악-이동-평균-계산하기">&lt;a href="#%eb%8b%a4%ec%9d%b4%ec%96%b4%ed%8a%b8-%ed%98%84%ed%99%a9-%ed%8c%8c%ec%95%85-%ec%9d%b4%eb%8f%99-%ed%8f%89%ea%b7%a0-%ea%b3%84%ec%82%b0%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>다이어트 현황 파악: 이동 평균 계산하기
&lt;/h3>&lt;ul>
&lt;li>이동 평균(Moving Average)
&lt;ul>
&lt;li>시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>eg) $N$개의 측정치가 주어질 때, M 간의 이동평균 계산
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">moving_average&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">partial_sum&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>2개의 for loop&lt;/p>
&lt;ol>
&lt;li>$j$를 사용하는 반복문: $N$&lt;/li>
&lt;li>$i$를 사용하는 반복문: $N-M+1$&lt;/li>
&lt;/ol>
&lt;p>-&amp;gt; $N * (N-M+1)=N^2-NM+N$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>중복된 계산을 없애기&lt;/p>
&lt;ul>
&lt;li>$M-1$일과 $M$일을 비교&lt;/li>
&lt;li>0과 M일만 차이나고 모두 동일하다&lt;/li>
&lt;li>$M-1$일에서 구한 몸무게 합에서 0일을 버리고 M일을 더하면?
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">moving_average&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">N&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">parital_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">partial_sum&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">partial_sum&lt;/span> &lt;span class="o">-=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>하나로 묶여 있던 두 개의 반복문이 분리&lt;br>
-&amp;gt; $M-1 +(N-M+1) = N$&lt;/li>
&lt;li>코드의 수행시간은 $N$에 정비례
&lt;ul>
&lt;li>
&lt;p>N이 2배가 되면 실행도 2배 걸리고, 반으로 줄어들면 수행시간도 반으로 줄어든다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>입력의 크기에 대비해 걸리는 시간을 그래프로 그러벼몬 정확히 직선이다&lt;/p>
&lt;p>-&amp;gt; &lt;strong>선형 시간(Linear Time) 알고리즘&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="43-선형-이하-시간-알고리듬">&lt;a href="#43-%ec%84%a0%ed%98%95-%ec%9d%b4%ed%95%98-%ec%8b%9c%ea%b0%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%eb%93%ac" class="header-anchor">&lt;/a>4.3 선형 이하 시간 알고리듬
&lt;/h2>&lt;ul>
&lt;li>어떤 문제건 입력된 자료를 모두 한 번 훑어 보는 데에는 입력의 크기에 비례하는 시간, 즉 선형시간이 걸린다.&lt;/li>
&lt;li>선형 시간보다 빠르게 동작하는 알고리즘은 입력된 값도 다 보지 않는다는 뜻.
&lt;ul>
&lt;li>입력으로 주어진 자료에 대해 우리가 알고 있는 지식을 활용하면 가능하다!&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="이진-탐색">&lt;a href="#%ec%9d%b4%ec%a7%84-%ed%83%90%ec%83%89" class="header-anchor">&lt;/a>이진 탐색
&lt;/h3>&lt;ul>
&lt;li>$binsearch(A[],x)$&lt;/li>
&lt;li>오름차순으로 정려된 $A[]$와 찾고 싶은 값 $x$가 주어질 때
&lt;ul>
&lt;li>$A[i-1] &amp;lt; x \le A[i]$인 $i$를 반환&lt;/li>
&lt;li>이 때 $A[-1] = - \infty, A[N] = \infty$로 가정한다.&lt;/li>
&lt;li>배열 $A[]$에서 $x$를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="44-지수-시간-알고리듬">&lt;a href="#44-%ec%a7%80%ec%88%98-%ec%8b%9c%ea%b0%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%eb%93%ac" class="header-anchor">&lt;/a>4.4 지수 시간 알고리듬
&lt;/h2>&lt;h3 id="다항시간-알고리듬">&lt;a href="#%eb%8b%a4%ed%95%ad%ec%8b%9c%ea%b0%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%eb%93%ac" class="header-anchor">&lt;/a>다항시간 알고리듬
&lt;/h3>&lt;ul>
&lt;li>반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘&lt;/li>
&lt;li>eg) 알러지가 심한 친구들
&lt;ul>
&lt;li>집들이에 $N$명의 친구를 초대 / 할 줄 아는 $M$가지 음식 중 무엇을 대접해야 할까?
&lt;img src="https://aiden-jeon.github.io/blog/imgs/algospot/chapter-04-1.jpeg"
loading="lazy"
alt="img"
>&lt;/li>
&lt;li>모든 답 후보 평가하기
&lt;ul>
&lt;li>이 문제는 여러 개의 답이 있을 수 있다.&lt;/li>
&lt;li>만들 수 있는 모든 음식을 다 만들면 된다 -&amp;gt; &lt;strong>더 적은 종류의 음식만을 준비하고 싶다.&lt;/strong>&lt;/li>
&lt;li>여러개의 답이 있고 그 중 가장 좋은 답을 찾을 때, 가장 간단한 방법은 모든 답을 일일이 고려해 보는 것
&lt;img src="https://aiden-jeon.github.io/blog/imgs/algospot/chapter-04-2.jpeg"
loading="lazy"
alt="img"
>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">INF&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">987654321&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">can_everybody_eat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">menu&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">select_menu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">menu&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">food&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">food&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">can_everybody_eat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">menu&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">menu&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">INF&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">select_menu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">menu&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">food&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">menu&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">food&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ret&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ret&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">select_menu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">menu&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">food&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">menu&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">ret&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="지수시간-알고리듬">&lt;a href="#%ec%a7%80%ec%88%98%ec%8b%9c%ea%b0%84-%ec%95%8c%ea%b3%a0%eb%a6%ac%eb%93%ac" class="header-anchor">&lt;/a>지수시간 알고리듬
&lt;/h3>&lt;p>N이 하나 증가할 때 마다 걸리는 시간이 배로 증가하는 알고리즘은 지수시간(exponential time)에 동작한다고 말한다.&lt;/p>
&lt;h2 id="45-시간-복잡도">&lt;a href="#45-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84" class="header-anchor">&lt;/a>4.5 시간 복잡도
&lt;/h2>&lt;h3 id="시간-복잡도">&lt;a href="#%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84" class="header-anchor">&lt;/a>시간 복잡도
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>시간 복잡도(Tiem Complexity)란 가장 널리 사용되는 알고리즘의 수행시간 기준&lt;/p>
&lt;/li>
&lt;li>
&lt;p>알고리즘에 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것&lt;/p>
&lt;/li>
&lt;li>
&lt;p>기본적인 연산이란?&lt;/p>
&lt;ul>
&lt;li>더 적게 쪼개질 없는 최소 크기의 연산
&lt;ul>
&lt;li>두 부호있는 32비트 정수의 사칙연산&lt;/li>
&lt;li>두 실수형 변수으 ㅣ대소 비교&lt;/li>
&lt;li>한 변수에 다른 변수 대입하기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쪼갤수 있는 연산
&lt;ul>
&lt;li>정수 배열 정리하기&lt;/li>
&lt;li>두 문자열에 서로 같은지 확인하기&lt;/li>
&lt;li>입력된 두 소인수 분해하기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>시간 복잡도가 높다 = 입력의 크기가 증가할 때 알고리즘의 수행시간이 더 빠르게 증가&lt;/p>
&lt;p>-&amp;gt; &lt;strong>시간 복잡도가 낮다고 해서 언제나 더 빠르게 증가하는 것은 아님!&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="입력의-종류에-따른-수행시간의-변화">&lt;a href="#%ec%9e%85%eb%a0%a5%ec%9d%98-%ec%a2%85%eb%a5%98%ec%97%90-%eb%94%b0%eb%a5%b8-%ec%88%98%ed%96%89%ec%8b%9c%ea%b0%84%ec%9d%98-%eb%b3%80%ed%99%94" class="header-anchor">&lt;/a>입력의 종류에 따른 수행시간의 변화
&lt;/h3>&lt;ul>
&lt;li>입력이 어떤 형태로 구성되어 있는지도 수행시간에 영향&lt;/li>
&lt;li>eg) 선형 탐색
&lt;ul>
&lt;li>운 좋게 처음에 찾을 수 있고/ 운 나쁘면 마지막에 찾을 수 도 있음&lt;/li>
&lt;li>최선의 수행시간:
&lt;ul>
&lt;li>찾으려는 원소가 맨 앞에 있음&lt;/li>
&lt;li>반목문의 수행 횟수: $1$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>최악의 수행시간:
&lt;ul>
&lt;li>배열에 해당 원소가 없을 때 알고리즘은 $N$번 반복하고 종료&lt;/li>
&lt;li>반목문의 수행 횟수: $N$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>평균적인 경우의 수행시간:
&lt;ul>
&lt;li>평균적인 경우의 수행시간을 분석하기 위해서는 존재할 수 있는 모든 입력의 등장 확률이 모두 같다고 가정&lt;/li>
&lt;li>만약 주어진 배열이 항상 원소를 포함한다고 가정하면 반환 값의 기대값은 $2 \over N$&lt;/li>
&lt;li>평균적인 수행 횟수: $2 \over N$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>대게 사용하는 것은 최악의 수행시간 혹은 수행시간의 기대치
&lt;ul>
&lt;li>많은 경우 이 두 기준은 따로 구분하지 않고 쓰인다&lt;/li>
&lt;li>여러 알고리즘에서 이 두 기준은 거의 같음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="점근적-시간-표기-o-표기">&lt;a href="#%ec%a0%90%ea%b7%bc%ec%a0%81-%ec%8b%9c%ea%b0%84-%ed%91%9c%ea%b8%b0-o-%ed%91%9c%ea%b8%b0" class="header-anchor">&lt;/a>점근적 시간 표기: $O$ 표기
&lt;/h3>&lt;ul>
&lt;li>대문자 $O$ 표기 (Big-O Notation)
&lt;ul>
&lt;li>주어진 함수에서 가장 빨리 증가하는 항만을 남긴채 나머지를 다 버리는 표기법&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>$O$ 표기법 의미
&lt;ul>
&lt;li>$O$ 표기법은 대략적으로 함수의 상한을 나타낸다.&lt;/li>
&lt;li>$N$에 대한 함수 $f(N)$에 주어질 때, $f(N)=O(G(N))$이라고 쓰는 것은 아주 큰 $N_0$와 $C(N_0,C&amp;gt;0)$를 적절히 선택하면 $N_0 \lt N)인 모든 $N$에 대해&lt;br>
$\left| f(N) \right| \le C*\left| g(N) \right| $ 이 참이 되도록 할 수 있다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>3. 코딩과 디버깅에 관하여</title><link>https://aiden-jeon.github.io/blog/p/3.-%EC%BD%94%EB%94%A9%EA%B3%BC-%EB%94%94%EB%B2%84%EA%B9%85%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC/</link><pubDate>Sat, 09 Oct 2021 00:00:00 +0000</pubDate><guid>https://aiden-jeon.github.io/blog/p/3.-%EC%BD%94%EB%94%A9%EA%B3%BC-%EB%94%94%EB%B2%84%EA%B9%85%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC/</guid><description>&lt;p>&lt;a class="link" href="https://book.algospot.com/" target="_blank" rel="noopener"
>알고리즘 문제 해결 전략&lt;/a>을 읽고 요약했습니다.&lt;/p>
&lt;hr>
&lt;h1 id="3-코딩과-디버깅에-관하여">&lt;a href="#3-%ec%bd%94%eb%94%a9%ea%b3%bc-%eb%94%94%eb%b2%84%ea%b9%85%ec%97%90-%ea%b4%80%ed%95%98%ec%97%ac" class="header-anchor">&lt;/a>3. 코딩과 디버깅에 관하여
&lt;/h1>&lt;h2 id="31-도입-코딩의-중요성을-간과하지-말라">&lt;a href="#31-%eb%8f%84%ec%9e%85-%ec%bd%94%eb%94%a9%ec%9d%98-%ec%a4%91%ec%9a%94%ec%84%b1%ec%9d%84-%ea%b0%84%ea%b3%bc%ed%95%98%ec%a7%80-%eb%a7%90%eb%9d%bc" class="header-anchor">&lt;/a>3.1 도입: 코딩의 중요성을 간과하지 말라
&lt;/h2>&lt;p>좋은 성적을 올리기 위한 비결은 당장 빨리 코드를 작성하기 보다 읽기 쉬운 코드를 작성하는 것&lt;/p>
&lt;ul>
&lt;li>복잡하고 읽기 어려운 코드
&lt;ul>
&lt;li>디버깅이 어렵다.&lt;/li>
&lt;li>한 번에 정확하게 작성하기 어렵다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="32-좋은-코드를-짜기-위한-원칙">&lt;a href="#32-%ec%a2%8b%ec%9d%80-%ec%bd%94%eb%93%9c%eb%a5%bc-%ec%a7%9c%ea%b8%b0-%ec%9c%84%ed%95%9c-%ec%9b%90%ec%b9%99" class="header-anchor">&lt;/a>3.2 좋은 코드를 짜기 위한 원칙
&lt;/h2>&lt;h3 id="1-간결한-코드를-작성하기">&lt;a href="#1-%ea%b0%84%ea%b2%b0%ed%95%9c-%ec%bd%94%eb%93%9c%eb%a5%bc-%ec%9e%91%ec%84%b1%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>1) 간결한 코드를 작성하기
&lt;/h3>&lt;ul>
&lt;li>코드가 짧으면 짧을 수록
&lt;ul>
&lt;li>오타나 단순한 버그가 사라질 우려가 줄어든다.&lt;/li>
&lt;li>디버깅이 쉬워진다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>프로그래밍과 다른 환경을 이용한 Trick
&lt;ul>
&lt;li>전역 변수 사용하기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-적극적으로-코드-재사용하기">&lt;a href="#2-%ec%a0%81%ea%b7%b9%ec%a0%81%ec%9c%bc%eb%a1%9c-%ec%bd%94%eb%93%9c-%ec%9e%ac%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>2) 적극적으로 코드 재사용하기
&lt;/h3>&lt;ul>
&lt;li>간결한 코드를 작성하기 위한 가장 직접적인 방법이다.&lt;/li>
&lt;li>같은 코드가 3번 이상 등장한다면 해당 코드를 함수로 분리해 재사용&lt;/li>
&lt;li>실무에서는 1 함수 1 기능의 원칙이 있지만 대회에서는&amp;hellip;
&lt;ul>
&lt;li>시간안에 문제를 풀 수가 없다.&lt;/li>
&lt;li>대회에서 작성한 코드는 재사용되지 않는다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="3-표준-라이브러리-공부하기">&lt;a href="#3-%ed%91%9c%ec%a4%80-%eb%9d%bc%ec%9d%b4%eb%b8%8c%eb%9f%ac%eb%a6%ac-%ea%b3%b5%eb%b6%80%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>3) 표준 라이브러리 공부하기
&lt;/h3>&lt;ul>
&lt;li>기본적으로 제공하는 알고리즘, 자료 구조는 직접 구현하지 않는다.
&lt;ul>
&lt;li>큐, 스택과 같은 자료구조&lt;/li>
&lt;li>정렬등의 기초 알고리즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-항상-같은-형태로-프로그램을-작성하기">&lt;a href="#4-%ed%95%ad%ec%83%81-%ea%b0%99%ec%9d%80-%ed%98%95%ed%83%9c%eb%a1%9c-%ed%94%84%eb%a1%9c%ea%b7%b8%eb%9e%a8%ec%9d%84-%ec%9e%91%ec%84%b1%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>4) 항상 같은 형태로 프로그램을 작성하기
&lt;/h3>&lt;ul>
&lt;li>자주 작성하는 알고리즘이나 코드에 대해서는 한 번 검증된 코드를 작성, 이것만 꾸준히 사용한다.&lt;/li>
&lt;li>도구가 아닌 문제에 집중할 수 있다.&lt;/li>
&lt;/ul>
&lt;h3 id="5-일관적이고-명료한-명명법-사용하기">&lt;a href="#5-%ec%9d%bc%ea%b4%80%ec%a0%81%ec%9d%b4%ea%b3%a0-%eb%aa%85%eb%a3%8c%ed%95%9c-%eb%aa%85%eb%aa%85%eb%b2%95-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>5) 일관적이고 명료한 명명법 사용하기
&lt;/h3>&lt;ul>
&lt;li>네이밍 컨벤션 잘 지키기&lt;/li>
&lt;li>함수의 반환값이 들어나게 이름 짓기
&lt;ul>
&lt;li>&lt;code>judge(...)&lt;/code> -&amp;gt; &lt;code>isInsideCircle(...)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="6-모든-자료를-정규화해서-저장하기">&lt;a href="#6-%eb%aa%a8%eb%93%a0-%ec%9e%90%eb%a3%8c%eb%a5%bc-%ec%a0%95%ea%b7%9c%ed%99%94%ed%95%b4%ec%84%9c-%ec%a0%80%ec%9e%a5%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>6) 모든 자료를 정규화해서 저장하기
&lt;/h3>&lt;ul>
&lt;li>같은 자료를 두 가지 형태로 저장하지 않는다.
&lt;ul>
&lt;li>eg 1) 기약 분수
&lt;ul>
&lt;li>$\frac{9}{6}$ -&amp;gt; $\frac{3}{2}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>eg 2) 두 점사이의 각도
&lt;ul>
&lt;li>$-30$, $330$, $690$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정규화는 프로그램이 자료를 입력 받거나 계산하자 마자 곧바로 이루어져야 한다.
&lt;ol>
&lt;li>자료를 표현하는 클래스의 생성자에서 수행&lt;/li>
&lt;li>외부에서 자료를 입력 받자마자 수행&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="7-코드와-데이터를-분리하기">&lt;a href="#7-%ec%bd%94%eb%93%9c%ec%99%80-%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%a5%bc-%eb%b6%84%eb%a6%ac%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>7) 코드와 데이터를 분리하기
&lt;/h3>&lt;ul>
&lt;li>코드의 논리와 상관없는 코드는 부리하기
&lt;ul>
&lt;li>eg) 월을 출력하는 함수
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">get_month_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">month&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">month&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;January&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">elif&lt;/span> &lt;span class="n">month&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;Feburary&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;December&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>=&amp;gt; 다음과 같이 수정하기
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">month_name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;January&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Feburary&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">...&lt;/span> &lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Decebmer&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>체스 게임에서 말들이 움직일 수 있는 상대적인 위치를 저장
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">knight_dx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">knight_dx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="33-자주-하는-실수">&lt;a href="#33-%ec%9e%90%ec%a3%bc-%ed%95%98%eb%8a%94-%ec%8b%a4%ec%88%98" class="header-anchor">&lt;/a>3.3 자주 하는 실수
&lt;/h2>&lt;h3 id="1-산술-오버플로">&lt;a href="#1-%ec%82%b0%ec%88%a0-%ec%98%a4%eb%b2%84%ed%94%8c%eb%a1%9c" class="header-anchor">&lt;/a>1) 산술 오버플로
&lt;/h3>&lt;p>계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로&lt;/p>
&lt;h3 id="2-배열-범위-밖-원소-접근">&lt;a href="#2-%eb%b0%b0%ec%97%b4-%eb%b2%94%ec%9c%84-%eb%b0%96-%ec%9b%90%ec%86%8c-%ec%a0%91%ea%b7%bc" class="header-anchor">&lt;/a>2) 배열 범위 밖 원소 접근
&lt;/h3>&lt;p>0을 시작으로하는 범위와 1로 시작하는 범위를 혼동하는 것&lt;/p>
&lt;p>eg) 1년에 포함된 달의 날짜 수를 저장하는 상수 배열&lt;/p>
&lt;ul>
&lt;li>1년 12달 -&amp;gt; 배열의 크기: 12&lt;/li>
&lt;li>입력 받은 값을 곧장 배열 인덱스로 사용할 경우&lt;/li>
&lt;/ul>
&lt;h3 id="3-일관되지-않은-범위-표현-방식-사용하기">&lt;a href="#3-%ec%9d%bc%ea%b4%80%eb%90%98%ec%a7%80-%ec%95%8a%ec%9d%80-%eb%b2%94%ec%9c%84-%ed%91%9c%ed%98%84-%eb%b0%a9%ec%8b%9d-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>3) 일관되지 않은 범위 표현 방식 사용하기
&lt;/h3>&lt;ul>
&lt;li>프로그램 내에서 여러 가지의 범위 표현 방식을 섞어서 사용할 경우
&lt;ul>
&lt;li>eg) $[2, 3, 4, &amp;hellip; , 12]$&lt;/li>
&lt;li>닫힌 구간: $[2, 12]$&lt;/li>
&lt;li>열린 구간: $(1, 13)$&lt;/li>
&lt;li>반 열린 구간: $[2, 13)$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>반 열린 구간의 장점
&lt;ol>
&lt;li>첫 번째 값과 마지막 값이 같은 구간을 이용하면 텅 빈 구간을 쉽게 표현할 수 있다.
&lt;ul>
&lt;li>eg) $[2, 2)$ -&amp;gt; $2 \leq i &amp;lt; 2$ -&amp;gt; 공집합&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>두 구간이 연속해 있는지 쉽게 알 수 있다.
&lt;ul>
&lt;li>eg) $[a, b)$ , $[c, d)$가 연속인지 보려면?&lt;br>
-&amp;gt; $b = c$, $a = d$ 인지만 확인하면 된다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>구간의 크기를 알기 쉽다.
&lt;ul>
&lt;li>eg) $[a, b)$ -&amp;gt; 자연수의 수는 $b-a$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>자연어에서 사용하는 범위와 다르기 때문에 문제가 생길 수 도 있다.
&lt;ul>
&lt;li>&lt;code>average(A[], i, j)&lt;/code>: 배열 &lt;code>A[]&lt;/code>의 부분 구간의 평균을 구하는 함수
&lt;ul>
&lt;li>반 열린 구간: &lt;code>average(a, 0, n)&lt;/code>&lt;/li>
&lt;li>닫힌 구간: &lt;code>average(a, 0, n-1)&lt;/code>&lt;br>
-&amp;gt; 함수 내에서 사용하는 표현 방법과 함수 밖에서 사용하는 표현 방법이 다르면 혼란이 발생.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-off-by-one-오류">&lt;a href="#4-off-by-one-%ec%98%a4%eb%a5%98" class="header-anchor">&lt;/a>4) Off-by-one 오류
&lt;/h3>&lt;ul>
&lt;li>계산의 큰 줄기는 맞지만 하나가 모자르거나 하나가 많아서 틀리는 오류들
&lt;ul>
&lt;li>eg 1) 100미터 길이의 담장에 10미터 간격으로 울타리 기둥을 세운다. 기둥이 몇 개 필요할까?
-&amp;gt; 정답은 10개가 아니라 11개&lt;/li>
&lt;li>eg 2) 정수 배열 &lt;code>A[]&lt;/code>가 주어질 때 &lt;code>A[i]&lt;/code> 부터 &lt;code>A[j]&lt;/code> 까지의 평균을 계산한다. 이 때 합을 얼마로 나누어야 할까?
-&amp;gt; $j-i$가 아니라 $j-i+1$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>언제 일어날까?
&lt;ul>
&lt;li>반복문에서 $&amp;lt;, &amp;gt;$ 연산자와 $\leq, \geq$ 연산자를 혼동하여 원서를 하나 더 적게, 혹은 하나 더 많이 분리하는 경우&lt;/li>
&lt;li>반 열린 구간과 닫힌 구간을 서로 혼용해 쓸 경우&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오류를 방지하는 방법
&lt;ul>
&lt;li>최소 입력이 주어졌을 때 코드가 어떻게 동작할지 되새겨 보기
&lt;ul>
&lt;li>eg 1) 담장의 길이가 0m 여도 기둥은 하나 박아야 한다.&lt;/li>
&lt;li>eg 2) &lt;code>A[1]&lt;/code> 부터 &lt;code>A[1]&lt;/code> 까지의 평균을 구할 때 0이 아니라 1로 나누어야 한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="5-컴파일러가-잡아주지-못하는-상수-오타">&lt;a href="#5-%ec%bb%b4%ed%8c%8c%ec%9d%bc%eb%9f%ac%ea%b0%80-%ec%9e%a1%ec%95%84%ec%a3%bc%ec%a7%80-%eb%aa%bb%ed%95%98%eb%8a%94-%ec%83%81%ec%88%98-%ec%98%a4%ed%83%80" class="header-anchor">&lt;/a>5) 컴파일러가 잡아주지 못하는 상수 오타
&lt;/h3>&lt;h3 id="6-스택-오버-플로">&lt;a href="#6-%ec%8a%a4%ed%83%9d-%ec%98%a4%eb%b2%84-%ed%94%8c%eb%a1%9c" class="header-anchor">&lt;/a>6) 스택 오버 플로
&lt;/h3>&lt;p>프로그램 실행 중 콜 스택이 오버플로해서 프로그램이 강제 종료되는 경우&lt;/p>
&lt;ul>
&lt;li>재귀 호출의 깊이가 너무 깊어져서 온다.&lt;/li>
&lt;/ul>
&lt;h3 id="7-다차원-배열-인덱스-순서-바꿔-쓰기">&lt;a href="#7-%eb%8b%a4%ec%b0%a8%ec%9b%90-%eb%b0%b0%ec%97%b4-%ec%9d%b8%eb%8d%b1%ec%8a%a4-%ec%88%9c%ec%84%9c-%eb%b0%94%ea%bf%94-%ec%93%b0%ea%b8%b0" class="header-anchor">&lt;/a>7) 다차원 배열 인덱스 순서 바꿔 쓰기
&lt;/h3>&lt;h3 id="8-잘못된-비교-함수-작성">&lt;a href="#8-%ec%9e%98%eb%aa%bb%eb%90%9c-%eb%b9%84%ea%b5%90-%ed%95%a8%ec%88%98-%ec%9e%91%ec%84%b1" class="header-anchor">&lt;/a>8) 잘못된 비교 함수 작성
&lt;/h3>&lt;h3 id="9-최소-최대-예외-잘못-다루기">&lt;a href="#9-%ec%b5%9c%ec%86%8c-%ec%b5%9c%eb%8c%80-%ec%98%88%ec%99%b8-%ec%9e%98%eb%aa%bb-%eb%8b%a4%eb%a3%a8%ea%b8%b0" class="header-anchor">&lt;/a>9) 최소, 최대 예외 잘못 다루기
&lt;/h3>&lt;p>가능한 입력 중 최솟 값과 최대 값이 예외가 되는 문제는 생각보다 많다.&lt;/p>
&lt;p>eg) 소수 판정 함수&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_prime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 짝수면 소수다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 다른 수로 나눠지면 소수다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>-&amp;gt; 2는 짝수이면서 소수&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_prime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">int&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="c1"># 짝수면 소수다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 다른 수로 나눠지면 소수다.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="kc">True&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>-&amp;gt; n=1은 두 조건문을 통과해 소수로 판정됨&lt;/p>
&lt;h3 id="10-연산자-우선-순위-잘못-쓰기">&lt;a href="#10-%ec%97%b0%ec%82%b0%ec%9e%90-%ec%9a%b0%ec%84%a0-%ec%88%9c%ec%9c%84-%ec%9e%98%eb%aa%bb-%ec%93%b0%ea%b8%b0" class="header-anchor">&lt;/a>10) 연산자 우선 순위 잘못 쓰기
&lt;/h3>&lt;ul>
&lt;li>연산자의 우선순위 잘 기억하기&lt;/li>
&lt;li>헷갈릴 경우 괄호로 적절히 감싸기&lt;/li>
&lt;/ul>
&lt;h3 id="11-너무-느린-입출력-방식-선택">&lt;a href="#11-%eb%84%88%eb%ac%b4-%eb%8a%90%eb%a6%b0-%ec%9e%85%ec%b6%9c%eb%a0%a5-%eb%b0%a9%ec%8b%9d-%ec%84%a0%ed%83%9d" class="header-anchor">&lt;/a>11) 너무 느린 입출력 방식 선택
&lt;/h3>&lt;h3 id="12-변수-초기화-문제">&lt;a href="#12-%eb%b3%80%ec%88%98-%ec%b4%88%ea%b8%b0%ed%99%94-%eb%ac%b8%ec%a0%9c" class="header-anchor">&lt;/a>12) 변수 초기화 문제
&lt;/h3>&lt;ul>
&lt;li>이전 입력에서 사용한 전역 변수 값을 초기화 하지 않고 그대로 사용하는 경우&lt;/li>
&lt;li>Tip) 예제 입력 파일을 두 번 반복해서 쓰기
&lt;ul>
&lt;li>eg)
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1234
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">321
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>-&amp;gt;
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-plain" data-lang="plain">&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1234
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">321
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1234
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">321
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예제간의 의존 관계 때문에 우연히 답이 나오는 경우를 방지할 수 있다.&lt;/li>
&lt;/ul>
&lt;h2 id="34-디버깅과-테스팅">&lt;a href="#34-%eb%94%94%eb%b2%84%ea%b9%85%ea%b3%bc-%ed%85%8c%ec%8a%a4%ed%8c%85" class="header-anchor">&lt;/a>3.4 디버깅과 테스팅
&lt;/h2>&lt;h3 id="1-디버깅에-관하여">&lt;a href="#1-%eb%94%94%eb%b2%84%ea%b9%85%ec%97%90-%ea%b4%80%ed%95%98%ec%97%ac" class="header-anchor">&lt;/a>1) 디버깅에 관하여
&lt;/h3>&lt;ul>
&lt;li>작은 입력에 대해 제대로 실행되나 확인하기&lt;/li>
&lt;li>단정문(assertion)을 쓴다.&lt;/li>
&lt;li>프로그램의 계산 중간 결과를 출력한다.&lt;/li>
&lt;/ul>
&lt;h3 id="2-테스팅에-관하여">&lt;a href="#2-%ed%85%8c%ec%8a%a4%ed%8c%85%ec%97%90-%ea%b4%80%ed%95%98%ec%97%ac" class="header-anchor">&lt;/a>2) 테스팅에 관하여
&lt;/h3>&lt;h4 id="스캐폴딩-scaffolding">&lt;a href="#%ec%8a%a4%ec%ba%90%ed%8f%b4%eb%94%a9-scaffolding" class="header-anchor">&lt;/a>스캐폴딩 (Scaffolding)
&lt;/h4>&lt;ul>
&lt;li>코드의 정당성을 확인하거나 반례를 찾을 때 유용하다.&lt;/li>
&lt;li>임의의 작은 입력을 자동으로 생성하는 프로그램 -&amp;gt; 검증하는 프로그램
&lt;ul>
&lt;li>eg) 직접 짠 정렬 알고리즘
&lt;ul>
&lt;li>난수 생성&lt;/li>
&lt;li>라이브러리 결과 == 직접 짠 결과&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>라이브러리가 없는 경우
&lt;ul>
&lt;li>작은 입력에서만 동작하는 더 느리지만 단순한 알고리즘을 사용해 검증&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="35-변수-범위의-이해">&lt;a href="#35-%eb%b3%80%ec%88%98-%eb%b2%94%ec%9c%84%ec%9d%98-%ec%9d%b4%ed%95%b4" class="header-anchor">&lt;/a>3.5 변수 범위의 이해
&lt;/h2>&lt;h3 id="1-산술-오버플로-1">&lt;a href="#1-%ec%82%b0%ec%88%a0-%ec%98%a4%eb%b2%84%ed%94%8c%eb%a1%9c-1" class="header-anchor">&lt;/a>1) 산술 오버플로
&lt;/h3>&lt;h3 id="2-너무-큰-결과">&lt;a href="#2-%eb%84%88%eb%ac%b4-%ed%81%b0-%ea%b2%b0%ea%b3%bc" class="header-anchor">&lt;/a>2) 너무 큰 결과
&lt;/h3>&lt;h3 id="3-너무-큰-중간값">&lt;a href="#3-%eb%84%88%eb%ac%b4-%ed%81%b0-%ec%a4%91%ea%b0%84%ea%b0%92" class="header-anchor">&lt;/a>3) 너무 큰 중간값
&lt;/h3>&lt;h3 id="4-너무-큰-무한대-값">&lt;a href="#4-%eb%84%88%eb%ac%b4-%ed%81%b0-%eb%ac%b4%ed%95%9c%eb%8c%80-%ea%b0%92" class="header-anchor">&lt;/a>4) 너무 큰 &amp;lsquo;무한대&amp;rsquo; 값
&lt;/h3>&lt;p>무한대에 해당하는 큰 값을 이용하는 것이 편리할 때가 있다.&lt;/p>
&lt;p>eg) 두 위치를 잇는 가장 짧은 길의 길이를 구하기&lt;br>
$s$ 에서 $t$ 까지 가는데 세 중간 지점 $a, b, c$ 중 항상 한 군데를 거쳐서 가야 한다.&lt;/p>
&lt;ul>
&lt;li>$(s,t)$ 구간의 최단 경로 길이 $dist(s,t)$ 계산 방법&lt;br>
\(
dist(s,t)=min
\begin{cases} dist(s,a) + dist(a,t) \\
dist(s,b) + dist(b,t) \\
dist(s,c) + dist(c,t) \\
\end{cases}
\)&lt;/li>
&lt;/ul>
&lt;p>만약 두 구간을 잇는 경우가 없을 경우에는?&lt;/p>
&lt;ol>
&lt;li>길이 존재하지 않음을 나타내는 특수한 값을 사용
&lt;ul>
&lt;li>이 값에 대한 예외 처리를 또 해주어야 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>실제로 나타날 리 없는 아주 큰 값을 반환
&lt;ul>
&lt;li>$min$ 에서 자동으로 필터링&lt;/li>
&lt;li>Tip) 987,654,321 같이 디버깅이 쉬운 큰 값을 추천
&lt;ul>
&lt;li>$2^30$에 가까운 매우 큰 값&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="5-오버플로-피해가기">&lt;a href="#5-%ec%98%a4%eb%b2%84%ed%94%8c%eb%a1%9c-%ed%94%bc%ed%95%b4%ea%b0%80%ea%b8%b0" class="header-anchor">&lt;/a>5) 오버플로 피해가기
&lt;/h3>&lt;ol>
&lt;li>더 큰 자료형 사용하기&lt;/li>
&lt;li>오버플로가 일어나지 않도록 연산의 순서 바꾸기&lt;/li>
&lt;li>계산 방법을 다르게 해 오버플로 피해가기&lt;/li>
&lt;/ol>
&lt;h3 id="6-자료형의-프로모션">&lt;a href="#6-%ec%9e%90%eb%a3%8c%ed%98%95%ec%9d%98-%ed%94%84%eb%a1%9c%eb%aa%a8%ec%85%98" class="header-anchor">&lt;/a>6) 자료형의 프로모션
&lt;/h3></description></item><item><title>2. 문제 해결 개관</title><link>https://aiden-jeon.github.io/blog/p/2.-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EA%B0%9C%EA%B4%80/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate><guid>https://aiden-jeon.github.io/blog/p/2.-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%EA%B0%9C%EA%B4%80/</guid><description>&lt;p>&lt;a class="link" href="https://book.algospot.com/" target="_blank" rel="noopener"
>알고리즘 문제 해결 전략&lt;/a>을 읽고 요약했습니다.&lt;/p>
&lt;hr>
&lt;h3 id="22-문제-해결-과정">&lt;a href="#22-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0-%ea%b3%bc%ec%a0%95" class="header-anchor">&lt;/a>2.2 문제 해결 과정
&lt;/h3>&lt;h4 id="1문제를-읽고-이해하기">&lt;a href="#1%eb%ac%b8%ec%a0%9c%eb%a5%bc-%ec%9d%bd%ea%b3%a0-%ec%9d%b4%ed%95%b4%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>1.문제를 읽고 이해하기
&lt;/h4>&lt;ul>
&lt;li>그림과 입출력 예제로 문제가 원하는 것을 유추하지 않기&lt;/li>
&lt;/ul>
&lt;h4 id="2재정의와-추상화">&lt;a href="#2%ec%9e%ac%ec%a0%95%ec%9d%98%ec%99%80-%ec%b6%94%ec%83%81%ed%99%94" class="header-anchor">&lt;/a>2.재정의와 추상화
&lt;/h4>&lt;ul>
&lt;li>자신이 다루기 쉬운 개념을 이용해, 문제를 자신의 언어로 풀어 쓰는 것&lt;/li>
&lt;li>문제의 추상화&lt;/li>
&lt;/ul>
&lt;h4 id="3계획-세우기">&lt;a href="#3%ea%b3%84%ed%9a%8d-%ec%84%b8%ec%9a%b0%ea%b8%b0" class="header-anchor">&lt;/a>3.계획 세우기
&lt;/h4>&lt;ul>
&lt;li>문제를 어떻게 해결할지 계획 세우기
&lt;ol>
&lt;li>문제를 어떻게 해결할지 결정&lt;/li>
&lt;li>사용할 알고리즘과 자료구조 선택&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="4계획-검증하기">&lt;a href="#4%ea%b3%84%ed%9a%8d-%ea%b2%80%ec%a6%9d%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>4.계획 검증하기
&lt;/h4>&lt;h4 id="5계획-수정하기">&lt;a href="#5%ea%b3%84%ed%9a%8d-%ec%88%98%ec%a0%95%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>5.계획 수정하기
&lt;/h4>&lt;h4 id="6회고하기">&lt;a href="#6%ed%9a%8c%ea%b3%a0%ed%95%98%ea%b8%b0" class="header-anchor">&lt;/a>6.회고하기
&lt;/h4>&lt;p>자신이 문제를 해결한 과정을 돌이켜 보고 개선하는 과정&lt;/p>
&lt;p>코드와 함께 자신의 경험을 기록으로 남기는 것&lt;/p>
&lt;ol>
&lt;li>문제의 간단한 해법
&lt;ul>
&lt;li>어떤 방식으로 접근했는지?&lt;/li>
&lt;li>문제의 해법을 찾는데 결정적인 깨달음을 무엇이 있는지?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오답의 원인
&lt;ul>
&lt;li>오답노트를 통해 자주 틀리는 부분 확인하기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 사람의 코드 보기&lt;/li>
&lt;li>문제를 풀지 못했을 때
&lt;ul>
&lt;li>일정 시간이 지나도록 고민해도 답을 못 찾을 때, 다른 사람의 풀이를 참조&lt;/li>
&lt;li>다른사람의 풀이를 참고했을 대
&lt;ul>
&lt;li>자신이 문제를 해결할 때 취했던 접근들을 되새김&lt;/li>
&lt;li>왜 이 풀이를 떠올리지 못 했는지 살펴 보기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="23-문제-해결-전략">&lt;a href="#23-%eb%ac%b8%ec%a0%9c-%ed%95%b4%ea%b2%b0-%ec%a0%84%eb%9e%b5" class="header-anchor">&lt;/a>2.3 문제 해결 전략
&lt;/h3>&lt;h4 id="가장-좋은-방법">&lt;a href="#%ea%b0%80%ec%9e%a5-%ec%a2%8b%ec%9d%80-%eb%b0%a9%eb%b2%95" class="header-anchor">&lt;/a>가장 좋은 방법
&lt;/h4>&lt;p>Best) 직관과 체계적인 접근&lt;br>
안되면? =&amp;gt; 체계적인 접근 방법&lt;br>
백지에서부터 차근차근 쌓아 올리는 방법&lt;/p>
&lt;h4 id="체계적인-적근을-위한-질문들">&lt;a href="#%ec%b2%b4%ea%b3%84%ec%a0%81%ec%9d%b8-%ec%a0%81%ea%b7%bc%ec%9d%84-%ec%9c%84%ed%95%9c-%ec%a7%88%eb%ac%b8%eb%93%a4" class="header-anchor">&lt;/a>체계적인 적근을 위한 질문들
&lt;/h4>&lt;h5 id="1-비슷한-문제를-풀어본-적이-있던가">&lt;a href="#1-%eb%b9%84%ec%8a%b7%ed%95%9c-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%ed%92%80%ec%96%b4%eb%b3%b8-%ec%a0%81%ec%9d%b4-%ec%9e%88%eb%8d%98%ea%b0%80" class="header-anchor">&lt;/a>1. 비슷한 문제를 풀어본 적이 있던가?
&lt;/h5>&lt;h5 id="2-단순한-방법에서-시작할-수-있을까-무식하게-풀-수-있을까">&lt;a href="#2-%eb%8b%a8%ec%88%9c%ed%95%9c-%eb%b0%a9%eb%b2%95%ec%97%90%ec%84%9c-%ec%8b%9c%ec%9e%91%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c-%eb%ac%b4%ec%8b%9d%ed%95%98%ea%b2%8c-%ed%92%80-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>2. 단순한 방법에서 시작할 수 있을까? (무식하게 풀 수 있을까?)
&lt;/h5>&lt;p>시간과 공간의 제약을 생각하지 않고 문제를 해결할 수 있는 가장 단순한 알고리즘&lt;br>
목표) 간단하게 풀 수 있는 문제를 너무 복잡하게 생각해서 어렵게 푸는 실수를 방지하기 위함&lt;br>
-&amp;gt; 만약 이 방법으로 안 풀린다면?&lt;/p>
&lt;ul>
&lt;li>최적화 과정 필요
&lt;ul>
&lt;li>좀 더 효율적인 자료 구조를 사용&lt;/li>
&lt;li>중복 계산 방지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>[예제 문제]&lt;/strong>&lt;br>
N(N&amp;lt;=30)개 이하의 사탕을 세 명의 어린이에게 공평하게 나눠 주려고 한다.&lt;br>
이 때 사탕의 무게는 20 이하의 정수이다.&lt;br>
공평하다 -&amp;gt; 어린이들 중 가장 무거운 무게와 가장 가벼운 무게의 차이가 적을 수록 공평하다.&lt;/p>
&lt;p>&lt;strong>[문제 풀이]&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>문제를 푸는 가장 단순한 방법&lt;/p>
&lt;ul>
&lt;li>어린이에게 나눠 주는 모든 방법을 하나씩 만들어 보기&lt;/li>
&lt;li>경우의 수) $3^N$, 최대 205조 개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>사탕의 총량을 상태 공간으로 하는 너비 우선 탐색&lt;/p>
&lt;ul>
&lt;li>상태 공간: (0,0,0)&lt;/li>
&lt;li>경우의 수) $(20*N+1)^3$, 최대 2억개&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&amp;hellip;&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="3-내가-문제를-푸는-과정을-수식화-할-수-있을까">&lt;a href="#3-%eb%82%b4%ea%b0%80-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%ed%91%b8%eb%8a%94-%ea%b3%bc%ec%a0%95%ec%9d%84-%ec%88%98%ec%8b%9d%ed%99%94-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>3. 내가 문제를 푸는 과정을 수식화 할 수 있을까?
&lt;/h5>&lt;h5 id="4-문제를-단순화-할-수-있을까">&lt;a href="#4-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%eb%8b%a8%ec%88%9c%ed%99%94-%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>4. 문제를 단순화 할 수 있을까?
&lt;/h5>&lt;p>2차원 -&amp;gt; 1차원&lt;/p>
&lt;ul>
&lt;li>왼쪽에 점이 더 많으면 왼쪽으로&lt;/li>
&lt;li>오른쪽에 점이 더 많으면 오른쪽으로&lt;/li>
&lt;/ul>
&lt;h5 id="5-그림으로-그려볼-수-있을까">&lt;a href="#5-%ea%b7%b8%eb%a6%bc%ec%9c%bc%eb%a1%9c-%ea%b7%b8%eb%a0%a4%eb%b3%bc-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>5. 그림으로 그려볼 수 있을까?
&lt;/h5>&lt;h5 id="6-수식으로-표현할-수-있을까">&lt;a href="#6-%ec%88%98%ec%8b%9d%ec%9c%bc%eb%a1%9c-%ed%91%9c%ed%98%84%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>6. 수식으로 표현할 수 있을까?
&lt;/h5>&lt;h5 id="7-문제를-분해할-수-있을까">&lt;a href="#7-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%eb%b6%84%ed%95%b4%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>7. 문제를 분해할 수 있을까?
&lt;/h5>&lt;p>더 다루기 쉬운 형태로 문제를 변형하는 것&lt;br>
문제의 제약 조건 분해&lt;/p>
&lt;h5 id="8-뒤에서-부터-생각해-문제를-풀-수-있을까">&lt;a href="#8-%eb%92%a4%ec%97%90%ec%84%9c-%eb%b6%80%ed%84%b0-%ec%83%9d%ea%b0%81%ed%95%b4-%eb%ac%b8%ec%a0%9c%eb%a5%bc-%ed%92%80-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>8. 뒤에서 부터 생각해 문제를 풀 수 있을까?
&lt;/h5>&lt;p>문제에 내재되어 있는 순서를 바꿔 보는 것&lt;/p>
&lt;ul>
&lt;li>ex) 사다리 게임에서 위로 올라가는 과정&lt;/li>
&lt;/ul>
&lt;h5 id="9-순서를-강제할-수-있을까">&lt;a href="#9-%ec%88%9c%ec%84%9c%eb%a5%bc-%ea%b0%95%ec%a0%9c%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>9. 순서를 강제할 수 있을까?
&lt;/h5>&lt;p>&lt;strong>[예제 문제]&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>어떤 순서로 버튼이 눌리던 상관 없다.&lt;/li>
&lt;li>같은 칸을 2번 누를 일은 없다.&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>[문제 풀이]&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>5x5 -&amp;gt; $2^{25}$ 가지의 경우의 수&lt;/li>
&lt;li>모든 칸을 왼쪽 위에서부터 순서대로 누르게 강제
&lt;ul>
&lt;li>$2^5$ -&amp;gt; &amp;hellip;&lt;/li>
&lt;li>누를 수 있는 경우의 수를 줄여 나가기&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h5 id="10-특정-형태의-답변을-고려할-수-있을까">&lt;a href="#10-%ed%8a%b9%ec%a0%95-%ed%98%95%ed%83%9c%ec%9d%98-%eb%8b%b5%eb%b3%80%ec%9d%84-%ea%b3%a0%eb%a0%a4%ed%95%a0-%ec%88%98-%ec%9e%88%ec%9d%84%ea%b9%8c" class="header-anchor">&lt;/a>10. 특정 형태의 답변을 고려할 수 있을까?
&lt;/h5>&lt;p>&lt;strong>정규화 기법(Canonicalization)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>우리가 고려해야할 답들 중 형태가 다르지만 결과적으로 똑같은 것들을 묶은 후 그들의 대표만 고려하는 방식&lt;/li>
&lt;/ul></description></item></channel></rss>